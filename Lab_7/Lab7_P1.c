/*------------------------------------------------------------------------------
 * File:        Lab07_P1.c 
 *
 * Function:    Changing brightness level of LED2 using PWM (MPS430F5529)
 *
 * Description: This C program controls the brightness of LED2 using a PWM signal 
 *              generated by Timer A. It offers six brightness levels (0%, 20%, 40%, 60%, 80%, and 100%), 
 *              starting at 20% by default.
 *
 * Clocks:      ACLK = LFXT1 = 32768Hz, MCLK = SMCLK = DCO = default (2^20 Hz)
 *              An external watch crystal between XIN & XOUT is required for ACLK
 *
 * Input:       Press SW2 to increase brightness and SW1 to decrease brightness
 * Output:      LED2 is on at 0-100% duty cycle at different brightnesses
 *
 * Author:      Anshika Sinha
 *------------------------------------------------------------------------------*/
#include "intrinsics.h"
#include <msp430F5529.h>
#include <stdio.h>

#define SW1 P2IN&BIT1                           // Switch 1 at P2.1
#define SW2 P1IN&BIT1                           // Switch 2 at P1.1

// Define PWM levels for 0%, 20%, 40%, 60%, 80%, and 100%
unsigned int dutyCycle = 2;             // Start at 20%
unsigned int clock = 1;   

void main(void) {
    WDTCTL = WDTPW | WDTHOLD;           // Stop watchdog timer
    
    // Configure LED
    P1DIR |= 0x01;                  // Set LED1 (P1.0) as output
    P1OUT |= 0x01;                 // Start LED1 as ON

    // Configure switches as inputs
    P2DIR &= ~BIT1;                 // Set P2.1 as input for SW1 input
    P2REN |= BIT1;                  // Enable pull-up register at P2.1
    P2OUT |= BIT1;

    P1DIR &= ~BIT1;                 // Set P1.1 as input for SW2 input
    P1REN |= BIT1;                  // Enable pull-up register at P1.1
    P1OUT |= BIT1;

    _EINT();                        // Enable interrupts
    // Configure switches for interrupts
    P2IE |= BIT1;                   // Enable interrupt for SW1 (P2.1)
    P2IES |= BIT1;                  // Set interrupt from high to low
    P2IFG &= ~BIT1;                 // Clear interrupt flag

    P1IE |= BIT1;                   // Enable interrupt for SW2 (P1.1)
    P1IES |= BIT1;                  // Set interrupt from high to low
    P1IFG &= ~BIT1;                 // Clear interrupt flag

    // Clock, ACLK continuous
    TA0CCTL0 = CCIE;                // Set output mode
    TA0CCR0 = 1;                    // Start at 20%
    TA0CTL = TASSEL_1 + MC_1;           // Set SMCLK to Up mode

    _BIS_SR(LPM3 + GIE);     // Enter low power mode 0
}

// Switch 1 ISR
#pragma vector=PORT2_VECTOR
__interrupt void Port2_ISR(void) {
    __delay_cycles(40000);              // debounce

    P2IE &= ~BIT1;                      // Disable interrupt
    if ((SW1) == 1)      
        return;                         // If SW1 is pressed
    if (dutyCycle > 0) {                
        dutyCycle -= 2;                 // decrease brightness
    }

    P2IFG &= ~BIT1;                     // Clear interrupt flag
    P2IE |= BIT1;                       // Enable interrupt
}

// Switch 2 ISR
#pragma vector=PORT1_VECTOR
__interrupt void Port1_ISR(void) {
    __delay_cycles(40000);              // debounce

    P1IE &= ~BIT1;                      // Disable interrupt
    if ((SW2) == 1)      
        return;                         // If SW2 is pressed
    if (dutyCycle < 10) {                
        dutyCycle += 2;                 // increase brightness
    }

    P1IFG &= ~BIT1;                     // Clear interrupt flag
    P1IE |= BIT1;                       // Enable interrupt
}

#pragma vector=TIMER0_A0_VECTOR
__interrupt void timerISR(void) {
    clock++;
    if (clock > 10)
        clock = 1;
    if (dutyCycle >= clock)
        P1OUT |= BIT0;
    else
        P1OUT &= ~BIT0;
}
